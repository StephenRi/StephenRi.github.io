---
layout:     post
title:      "[Java]设计模式"
subtitle:   "大话设计模式-常用设计模式总结"
date:       2020-05-24 12:00:00
author:     "Stephen.Ri"
header-img: "img/apple2.jpg"
catalog: true
tags:
    - Java
--- 

> 通过封装、继承、多态把程序的耦合度降低；通过设计模式使程序更加灵活，容易修改，易于复用。

## 六大设计原则

| 设计原则 | WHAT | WHY | HOW |
| :-: | :-: | :-: | :-: |
| 单一职责 | 就一个类而言，应该仅有一个引起它变化的原因 | 如果一个类承担的指责过多，就等于把这些指责耦合在一起，一个指责的变化可能会削弱或者抑制这个类完成其他指责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受意想不到的破坏 | 如果你能想到多于一个的动机去改变一个类，那么这个类就具有多于一个的指责 |
| 开放-封闭 | 对于扩展是开放的，对于更改是封闭的 | 为了让程序能面对需求的改变可以保持相对稳定，从而使系统在第一个版本后快速迭代。可维护、可扩展、可复用、灵活性好 | 最初编写代码时，假设变化不会发生。当变化发生时，创建抽象来隔离以后发生的同类变化。拒绝不成熟的抽象和抽象本身一样重要 |
| 里氏代换 | 子类型必须能够替换掉父类型 | 只有当子类可以替换掉父类，软件单位的功能不受到影响时，父类才能真正被复用，子类也能够在父类的基础上增加新的行为 | 继承 |
| 依赖倒转 | 抽象不应该依赖细节，细节应该依赖抽象 | 如果不管高层模块还是底层模块，都依赖于抽象（接口，或抽象类），只要接口是稳定的，那么任何一个更改都不用担心其他受到影响 | 针对接口编程。谁也不要依赖谁 |
| 迪米特 | 最少知识原则。如果两个类不必直接通信，那就不应当发生直接的相互作用 | 类之间的耦合越弱，越有利于复用，一个弱耦合的类被修改，不会波及到有关系的类 | 在类的结构设计上，每个类都应当尽量降低成员的访问权限 |

## 单例模式

类自身负责保存它的唯一实例。这个类可以保证没有其他实例可以被创建，并且它可以提供一个访问该实例的方法

![单例模式]({{site.baseurl}}/img/imgInBlog/pattern5.png)

### 饿汉式

```Java
public class Singleton {  
    private static Singleton instance = new Singleton();  
    private Singleton (){}  
    public static Singleton getInstance() {  
        return instance;  
    }  
}
```

## 简单工厂模式

用一个单独的类来创造实例，这就是工厂

![简单工厂模式]({{site.baseurl}}/img/imgInBlog/pattern0.jpg)

在用简单工厂的地方可以考虑用反射技术去除switch或if，解除分支判断带来的耦合

## 工厂方法模式

定义一个创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类

![工厂方法模式]({{site.baseurl}}/img/imgInBlog/pattern3.png)

## 抽象工厂模式

提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类。

![抽象工厂模式]({{site.baseurl}}/img/imgInBlog/pattern4.jpg)

### 抽象工厂与简单工厂结合

可以用一个简单工厂类`ProductAccess`代替`AbstractFactory, ConcreteFactory1, ConcreteFactory2`三个类。简化客户端实现。

## 策略模式

策略模式是一种定义一系列算法的方法，从概念上来看，所有这些算法完成的都是相同的工作，只是实现不同，它可以以相同的方式调用所有的算法，减少了各种算法类与使用算法类之间的耦合

![策略模式]({{site.baseurl}}/img/imgInBlog/pattern1.jpg)

### 策略模式与简单工厂结合

在基本的策略模式中，选择所用具体实现的职责由客户端对象承担，并转给策略模式的Context对象。这本身并没有解除客户端需要选择判断的压力，而策略模式与简单工厂模式结合后，选择具体实现的职责也可以由Context来承担，这就最大化地减轻了客户端的职责

## 状态模式

当一个对象的内在状态改变时,允许改变其行为,这个对象看起来是改变了其类。

![状态模式]({{site.baseurl}}/img/imgInBlog/pattern11.png)

消除庞大的条件分支语句。

当一个对象的行为取决于它的状态，并且它必须在运行时刻根据状态改变它的行为时，就可以考虑使用状态模式了。

状态模式主要解决的是当控制一个对象状态转换的条件表达式过于复杂时的情况。把状态的判断逻辑转移到表示不同状态的一系列类当中，可以把复杂的判断逻辑简化。

## 建造者模式

将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示

如果我们使用了建造者模式，那么用户就只需指定需要建造的类型就可以得到他们，而具体建造的过程和细节就不需知道了

![建造者模式]({{site.baseurl}}/img/imgInBlog/pattern9.png)

## 访问者模式

访问者模式讲的是表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作

![访问者模式]({{site.baseurl}}/img/imgInBlog/pattern2.png)

适用于有比较稳定的数据结构，又有易于变化的算法的情况

## 观察者模式

又叫做发布—订阅模式（Publish/Subscribe），定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时会通知所有观察者对象，使他们能够自动更新自己

![观察者模式]({{site.baseurl}}/img/imgInBlog/pattern10.png)

当一个对象的改变需要同时改变其他对象，而且它不知道具体有多少对象有待改变时应该考虑观察者模式

观察者模式所做的工作其实就是在解除耦合。让耦合的双方都依赖于抽象，而不是依赖于具体

## 代理模式

为其他对象提供一种代理以控制对这个对象的访问

![代理模式]({{site.baseurl}}/img/imgInBlog/pattern6.png)

### 代理模式应用

1. **远程代理：**为一个对象在不同的地址空间提供局部代表。这样可以隐藏一个对象存在于不同地址空间的事实。
2. 虚拟代理：根据需要创建开销很大的对象。通过它来存放实例化需要很长时间的真实对象。比如上面这张代理模式图片的加载。如果网络较慢，会有一个框代理图片。
3. 安全代理：用于控制真实对象访问时的权限。
4. 智能指引：当调用真实的对象时，代理处理另外一些事。

总之，代理模式其实就是在访问对象时引入一定程度的间接性，因为这种间接性，可以附加多种用途

## 适配器模式

将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。

![适配器模式]({{site.baseurl}}/img/imgInBlog/pattern12.png)

适配器模式主要应用于希望复用一些现存的类，但是接口又与复用环境要求不一致的情况

## 组合模式

将对象组合成树形结构以表示‘部分-整体’的层次结构。组合模式**使得用户对单个对象和组合对象的使用具有一致性**

![组合模式]({{site.baseurl}}/img/imgInBlog/pattern14.png)

### 透明方式 vs 安全模式

1. **透明方式：**在Component中声明所有用来管理子对象的方法。好处是叶节点和枝节点对于外界没有区别，他们具备完全一致的行为接口。但问题也很明显，因为Leaf类本身不具备Add、Remove方法的功能，所以实现它是没有意义的。
2. **安全方式：**在Component接口中不去声明Add和Remove方法，而是在Composite声明所有用来管理子类对象的方法。由于不够透明，所以Leaf和Composite不具有相同的接口，客户端的调用需要做相应的判断，带来了不便。

## 原型模式

用原型实例指定创建对象的各类，并且通过拷贝这些原型创建新的对象。通俗讲就是从一个对象再创建另外一个可定制的对象,而且不需知道任何创建的细节

![原型模式]({{site.baseurl}}/img/imgInBlog/pattern7.png)

Java中直接实现`Cloneable`接口即可

### 深复制 vs 浅复制

1. **浅复制：**被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用都仍然指向原来的对象
2. **深复制：**把引用对象的变量指向复制过的新对象，而不是原有的被引用的对象

#### 常用深复制方法

1. 让每个引用类型属性内部都重写`clone()`方法
2. 利用序列化

## 迭代器模式

提供一种方法顺序地访问一个聚合对象中各个元素，而又不暴露该对象的内部表示

![迭代器模式]({{site.baseurl}}/img/imgInBlog/pattern15.png)

迭代器模式就是分离了集合对象的遍历行为，抽象出一个迭代器中类来负责，这样既可以做到不暴露集合的内部结构，又可让外部代码透明地访问集合内部的数据

需要对聚焦对象有多种方法遍历时，可以考虑用迭代器模式

## 备忘录模式

在不破坏封装性的前提下,捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将对象回复到原先保存的状态。

![备忘录模式]({{site.baseurl}}/img/imgInBlog/pattern13.png)

把要保存的细节给封装在了Memento中，哪一天要更改保存的细节也不用影响客户端

## 外观模式

为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用

![外观模式]({{site.baseurl}}/img/imgInBlog/pattern8.png)

## 模式间对比

### 简单工厂 vs 工厂方法 vs 抽象工厂

**简单工厂模式**的工厂类包含了必要的逻辑判断，根据客户端的选择条件动态实例化相关的类。对于客户端来说，去除了与具体产品的依赖。

**工厂方法模式**把简单工厂的内部逻辑判断移到了客户端代码来进行。工厂方法克服了简单工厂违背**开放-封闭原则**的缺点，又保持了封装创建对象过程的优点。

**抽象工厂模式**易于交换产品系列。客户端通过抽象接口操纵实例，产品的具体类名也被具体工厂的实现分离。