---
layout:     post
title:      "[Java]设计模式"
subtitle:   "大话设计模式-常用设计模式总结"
date:       2020-05-24 12:00:00
author:     "Stephen.Ri"
header-img: "img/apple2.jpg"
catalog: true
tags:
    - Java
--- 

> 通过封装、继承、多态把程序的耦合度降低；通过设计模式使程序更加灵活，容易修改，易于复用。

## 单例模式

类自身负责保存它的唯一实例。这个类可以保证没有其他实例可以被创建，并且它可以提供一个访问该实例的方法

![简单工厂模式]({{site.baseurl}}/img/imgInBlog/pattern5.png)

### 饿汉式

```Java
public class Singleton {  
    private static Singleton instance = new Singleton();  
    private Singleton (){}  
    public static Singleton getInstance() {  
        return instance;  
    }  
}
```

## 简单工厂模式

用一个单独的类来创造实例，这就是工厂

![简单工厂模式]({{site.baseurl}}/img/imgInBlog/pattern0.jpg)

在用简单工厂的地方可以考虑用反射技术去除switch或if，解除分支判断带来的耦合

## 工厂方法模式

定义一个创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类

![工厂方法模式]({{site.baseurl}}/img/imgInBlog/pattern3.png)

## 抽象工厂模式

提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类。

![抽象工厂模式]({{site.baseurl}}/img/imgInBlog/pattern4.jpg)

### 抽象工厂与简单工厂结合

可以用一个简单工厂类`ProductAccess`代替`AbstractFactory, ConcreteFactory1, ConcreteFactory2`三个类。简化客户端实现。

## 策略模式

策略模式是一种定义一系列算法的方法，从概念上来看，所有这些算法完成的都是相同的工作，只是实现不同，它可以以相同的方式调用所有的算法，减少了各种算法类与使用算法类之间的耦合

![策略模式]({{site.baseurl}}/img/imgInBlog/pattern1.jpg)

### 策略模式与简单工厂结合

在基本的策略模式中，选择所用具体实现的职责由客户端对象承担，并转给策略模式的Context对象。这本身并没有解除客户端需要选择判断的压力，而策略模式与简单工厂模式结合后，选择具体实现的职责也可以由Context来承担，这就最大化地减轻了客户端的职责

## 访问者模式

访问者模式讲的是表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作

![访问者模式]({{site.baseurl}}/img/imgInBlog/pattern2.png)

适用于有比较稳定的数据结构，又有易于变化的算法的情况

# 模式间对比

## 简单工厂 vs 工厂方法 vs 抽象工厂

**简单工厂模式**的工厂类包含了必要的逻辑判断，根据客户端的选择条件动态实例化相关的类。对于客户端来说，去除了与具体产品的依赖。

**工厂方法模式**把简单工厂的内部逻辑判断移到了客户端代码来进行。工厂方法克服了简单工厂违背**开放-封闭原则**的缺点，又保持了封装创建对象过程的优点。

**抽象工厂模式**易于交换产品系列。客户端通过抽象接口操纵实例，产品的具体类名也被具体工厂的实现分离。