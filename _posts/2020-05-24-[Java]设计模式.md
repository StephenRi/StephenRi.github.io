---
layout:     post
title:      "[Java]设计模式"
subtitle:   "大话设计模式-常用设计模式总结"
date:       2020-05-24 12:00:00
author:     "Stephen.Ri"
header-img: "img/apple2.jpg"
catalog: true
tags:
    - Java
--- 

> 通过封装、继承、多态把程序的耦合度降低；通过设计模式使程序更加灵活，容易修改，易于复用。

## 六大设计原则

| 设计原则 | WHAT | WHY | HOW |
| :-: | :-: | :-: | :-: |
| 单一职责 | 就一个类而言，应该仅有一个引起它变化的原因 | 如果一个类承担的指责过多，就等于把这些指责耦合在一起，一个指责的变化可能会削弱或者抑制这个类完成其他指责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受意想不到的破坏 | 如果你能想到多于一个的动机去改变一个类，那么这个类就具有多于一个的指责 |
| 开放-封闭 | 对于扩展是开放的，对于更改是封闭的 | 为了让程序能面对需求的改变可以保持相对稳定，从而使系统在第一个版本后快速迭代。可维护、可扩展、可复用、灵活性好 | 最初编写代码时，假设变化不会发生。当变化发生时，创建抽象来隔离以后发生的同类变化。拒绝不成熟的抽象和抽象本身一样重要 |
| 里氏代换 | 子类型必须能够替换掉父类型 | 只有当子类可以替换掉父类，软件单位的功能不受到影响时，父类才能真正被复用，子类也能够在父类的基础上增加新的行为 | 继承 |
| 依赖倒转 | 抽象不应该依赖细节，细节应该依赖抽象 | 如果不管高层模块还是底层模块，都依赖于抽象（接口，或抽象类），只要接口是稳定的，那么任何一个更改都不用担心其他受到影响 | 针对接口编程。谁也不要依赖谁 |
| 迪米特 | 最少知识原则。如果两个类不必直接通信，那就不应当发生直接的相互作用 | 类之间的耦合越弱，越有利于复用，一个弱耦合的类被修改，不会波及到有关系的类 | 在类的结构设计上，每个类都应当尽量降低成员的访问权限 |

## 单例模式

类自身负责保存它的唯一实例。这个类可以保证没有其他实例可以被创建，并且它可以提供一个访问该实例的方法

![单例模式]({{site.baseurl}}/img/imgInBlog/pattern5.png)

### 饿汉式

```Java
public class Singleton {  
    private static Singleton instance = new Singleton();  
    private Singleton (){}  
    public static Singleton getInstance() {  
        return instance;  
    }  
}
```

## 简单工厂模式

用一个单独的类来创造实例，这就是工厂

![简单工厂模式]({{site.baseurl}}/img/imgInBlog/pattern0.jpg)

在用简单工厂的地方可以考虑用反射技术去除switch或if，解除分支判断带来的耦合

## 工厂方法模式

定义一个创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类

![工厂方法模式]({{site.baseurl}}/img/imgInBlog/pattern3.png)

## 抽象工厂模式

提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类。

![抽象工厂模式]({{site.baseurl}}/img/imgInBlog/pattern4.jpg)

### 抽象工厂与简单工厂结合

可以用一个简单工厂类`ProductAccess`代替`AbstractFactory, ConcreteFactory1, ConcreteFactory2`三个类。简化客户端实现。

## 策略模式

策略模式是一种定义一系列算法的方法，从概念上来看，所有这些算法完成的都是相同的工作，只是实现不同，它可以以相同的方式调用所有的算法，减少了各种算法类与使用算法类之间的耦合

![策略模式]({{site.baseurl}}/img/imgInBlog/pattern1.jpg)

### 策略模式与简单工厂结合

在基本的策略模式中，选择所用具体实现的职责由客户端对象承担，并转给策略模式的Context对象。这本身并没有解除客户端需要选择判断的压力，而策略模式与简单工厂模式结合后，选择具体实现的职责也可以由Context来承担，这就最大化地减轻了客户端的职责

## 建造者模式

将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示

如果我们使用了建造者模式，那么用户就只需指定需要建造的类型就可以得到他们，而具体建造的过程和细节就不需知道了

![建造者模式]({{site.baseurl}}/img/imgInBlog/pattern9.png)

## 访问者模式

访问者模式讲的是表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作

![访问者模式]({{site.baseurl}}/img/imgInBlog/pattern2.png)

适用于有比较稳定的数据结构，又有易于变化的算法的情况

## 观察者模式

又叫做发布—订阅模式（Publish/Subscribe），定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时会通知所有观察者对象，使他们能够自动更新自己

![观察者模式]({{site.baseurl}}/img/imgInBlog/pattern10.png)

当一个对象的改变需要同时改变其他对象，而且它不知道具体有多少对象有待改变时应该考虑观察者模式

观察者模式所做的工作其实就是在解除耦合。让耦合的双方都依赖于抽象，而不是依赖于具体

## 代理模式

为其他对象提供一种代理以控制对这个对象的访问

![代理模式]({{site.baseurl}}/img/imgInBlog/pattern6.png)

### 代理模式应用

1. **远程代理：**为一个对象在不同的地址空间提供局部代表。这样可以隐藏一个对象存在于不同地址空间的事实。
2. 虚拟代理：根据需要创建开销很大的对象。通过它来存放实例化需要很长时间的真实对象。比如上面这张代理模式图片的加载。如果网络较慢，会有一个框代理图片。
3. 安全代理：用于控制真实对象访问时的权限。
4. 智能指引：当调用真实的对象时，代理处理另外一些事。

总之，代理模式其实就是在访问对象时引入一定程度的间接性，因为这种间接性，可以附加多种用途

## 原型模式

用原型实例指定创建对象的各类，并且通过拷贝这些原型创建新的对象。通俗讲就是从一个对象再创建另外一个可定制的对象,而且不需知道任何创建的细节

![原型模式]({{site.baseurl}}/img/imgInBlog/pattern7.png)

Java中直接实现`Cloneable`接口即可

## 外观模式

为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用

![外观模式]({{site.baseurl}}/img/imgInBlog/pattern8.png)

### 深复制 vs 浅复制

1. **浅复制：**被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用都仍然指向原来的对象
2. **深复制：**把引用对象的变量指向复制过的新对象，而不是原有的被引用的对象

#### 常用深复制方法

1. 让每个引用类型属性内部都重写`clone()`方法
2. 利用序列化

## 模式间对比

### 简单工厂 vs 工厂方法 vs 抽象工厂

**简单工厂模式**的工厂类包含了必要的逻辑判断，根据客户端的选择条件动态实例化相关的类。对于客户端来说，去除了与具体产品的依赖。

**工厂方法模式**把简单工厂的内部逻辑判断移到了客户端代码来进行。工厂方法克服了简单工厂违背**开放-封闭原则**的缺点，又保持了封装创建对象过程的优点。

**抽象工厂模式**易于交换产品系列。客户端通过抽象接口操纵实例，产品的具体类名也被具体工厂的实现分离。