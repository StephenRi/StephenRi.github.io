---
layout:     post
title:      "[Java]设计模式"
subtitle:   "大话设计模式-常用设计模式总结"
date:       2020-05-24 12:00:00
author:     "Stephen.Ri"
header-img: "img/apple2.jpg"
catalog: true
tags:
    - Java
--- 

> 通过封装、继承、多态把程序的耦合度降低；通过设计模式使程序更加灵活，容易修改，易于复用。

## 单例模式

类自身负责保存它的唯一实例。这个类可以保证没有其他实例可以被创建，并且它可以提供一个访问该实例的方法

![单例模式]({{site.baseurl}}/img/imgInBlog/pattern5.png)

### 饿汉式

```Java
public class Singleton {  
    private static Singleton instance = new Singleton();  
    private Singleton (){}  
    public static Singleton getInstance() {  
        return instance;  
    }  
}
```

## 简单工厂模式

用一个单独的类来创造实例，这就是工厂

![简单工厂模式]({{site.baseurl}}/img/imgInBlog/pattern0.jpg)

在用简单工厂的地方可以考虑用反射技术去除switch或if，解除分支判断带来的耦合

## 工厂方法模式

定义一个创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类

![工厂方法模式]({{site.baseurl}}/img/imgInBlog/pattern3.png)

## 抽象工厂模式

提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类。

![抽象工厂模式]({{site.baseurl}}/img/imgInBlog/pattern4.jpg)

### 抽象工厂与简单工厂结合

可以用一个简单工厂类`ProductAccess`代替`AbstractFactory, ConcreteFactory1, ConcreteFactory2`三个类。简化客户端实现。

## 策略模式

策略模式是一种定义一系列算法的方法，从概念上来看，所有这些算法完成的都是相同的工作，只是实现不同，它可以以相同的方式调用所有的算法，减少了各种算法类与使用算法类之间的耦合

![策略模式]({{site.baseurl}}/img/imgInBlog/pattern1.jpg)

### 策略模式与简单工厂结合

在基本的策略模式中，选择所用具体实现的职责由客户端对象承担，并转给策略模式的Context对象。这本身并没有解除客户端需要选择判断的压力，而策略模式与简单工厂模式结合后，选择具体实现的职责也可以由Context来承担，这就最大化地减轻了客户端的职责

## 访问者模式

访问者模式讲的是表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作

![访问者模式]({{site.baseurl}}/img/imgInBlog/pattern2.png)

适用于有比较稳定的数据结构，又有易于变化的算法的情况

## 代理模式

为其他对象提供一种代理以控制对这个对象的访问

![代理模式]({{site.baseurl}}/img/imgInBlog/pattern6.png)

### 代理模式应用

1. **远程代理：**为一个对象在不同的地址空间提供局部代表。这样可以隐藏一个对象存在于不同地址空间的事实。
2. 虚拟代理：根据需要创建开销很大的对象。通过它来存放实例化需要很长时间的真实对象。比如上面这张代理模式图片的加载。如果网络较慢，会有一个框代理图片。
3. 安全代理：用于控制真实对象访问时的权限。
4. 智能指引：当调用真实的对象时，代理处理另外一些事。

总之，代理模式其实就是在访问对象时引入一定程度的间接性，因为这种间接性，可以附加多种用途

## 原型模式

用原型实例指定创建对象的各类，并且通过拷贝这些原型创建新的对象。通俗讲就是从一个对象再创建另外一个可定制的对象,而且不需知道任何创建的细节。

![原型模式]({{site.baseurl}}/img/imgInBlog/pattern7.png)

Java中直接实现`Cloneable`接口即可

### 深复制 vs 浅复制

1. **浅复制：**被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用都仍然指向原来的对象
2. **深复制：**把引用对象的变量指向复制过的新对象，而不是原有的被引用的对象

#### 常用深复制方法

1. 让每个引用类型属性内部都重写`clone()`方法
2. 利用序列化

## 模式间对比

### 简单工厂 vs 工厂方法 vs 抽象工厂

**简单工厂模式**的工厂类包含了必要的逻辑判断，根据客户端的选择条件动态实例化相关的类。对于客户端来说，去除了与具体产品的依赖。

**工厂方法模式**把简单工厂的内部逻辑判断移到了客户端代码来进行。工厂方法克服了简单工厂违背**开放-封闭原则**的缺点，又保持了封装创建对象过程的优点。

**抽象工厂模式**易于交换产品系列。客户端通过抽象接口操纵实例，产品的具体类名也被具体工厂的实现分离。