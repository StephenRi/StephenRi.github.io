---
layout:     post
title:      "[Learning]剑指Offer"
subtitle:   "剑指Offer刷题记录"
date:       2018-03-02 12:00:00
author:     "Stephen.Ri"
header-img: "img/read-bg.jpg"
catalog: true
tags:
    - Learning
---

## 面试题1:赋值运算符函数

**类型CMyString，请为该类型添加赋值运算符函数。**

```
CMyString & CMyString::operator = (const CMyString & str)
{
    if(this == &str)
        return *this;
    delete [] m_pData;
    m_pDate = NULL;
    m_pData = new char[strlen(str.m_pData) + 1];
    strcpy(m_pdata, str.m_pData);
    return *this;
}
```

1. 只有返回一个引用（\*this），才可以被连续赋值。

2. 参数设置为引用，防止从形参到实参调用复制构造函数。

3. 释放自己本身的内存，防止程序发生内存泄漏。

4. 要判断传入参数和\*this是否是同一个实例。


## 面试题3:二维数组中的查找

**在一个二维数组中，每一行都按照从左到右递增的顺序排列，每一列都按照从上倒下递增的顺序排列。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否包含该整数。**

>首先选取数组中右上角的数字。如果该数字等于要查找的数字，查找结束；  
>如果该数字大于要查找的数字，剔除这个数字所在的列；  
>输入该数字小于要查找的数字，剔除这个数字所在的行。

1. STL中的vector每次扩充容量时，新的容量都是前一次的两倍。

## 面试题4:替换空格

**请实现一个函数，把字符串中的每个空格替换成“%20”。例如输入“We are happy.”，则输出“We%20are%20happy”**

>假设我们要在原来的字符串上做替换，并且输入的字符串后面有足够多的空余内存。

>首先遍历一次字符串，统计处字符串中空格的总数，计算出替换后字符串的总长度。  
>从字符串的后面开始复制和替换。准备两个指针p1和p2，分别指向原字符串的末尾和替换后字符串的末尾。  
>一步步向前移动p1，逐个把它指向的字符复制到p2未知。如果p1指向的是空格，就变成“%20”。

1. 合并两个数组时，如果从前往后复制每个数字需要重复移动数字多次，那么我们可以考虑**从后往前**复制，这样能减少移动的次数，提高效率。

## 面试题5:从尾到头打印链表

**输入一个链表的头节点，从尾到头反过来打印出每个节点的值。**

>链表遍历的顺序是从头到尾的顺序，输出的顺序却是从尾到头，这就是典型的**后进先出**，我们可以用**栈**来实现这种顺序。

`stack<ListNode *> nodes`

## 面试题6:重建二叉树

**输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1, 2, 4, 7, 3, 5, 6, 8}和中序遍历序列{4, 7, 2, 1, 5, 3, 8, 6}，重建二叉树并输出头节点。**

>前序遍历的第一个数字是根节点的值，扫描中序遍历，就能确定根节点的值的位置。  
>根据中序遍历的特点，根节点的值前面的就是左子树的值，根节点的值后面的就是右子树的值。  
>可以用**递归**实现。

## 面试题7:用两个栈实现队列

**用两个栈实现一个队列。队列的声明如下，请实现它的两个函数appendTail和deleteHead，分别完成在队列尾部插入节点和在队列头部删除节点的功能。**

>我们有两个栈stack1和stack2。  
>插入的时候都是直接用stack1.push(element)。  
>删除的时候：当stack2中不为空时，stack2中栈顶的元素就是最先进入队列的元素，可以弹出。如果stack2为空，我们就把stack1中的元素逐个弹出并压入stack2，因为先进入stack1的元素在栈底，经过弹出并压入之后处于stack2的栈顶，可以直接弹出。

## 番外题：快速排序

>实现快拍的关键在于现在数组中选择一个数字，接下来把数组中的数字分为两部分，比选择的数字小的数字放在数组的左边，比选择的数字大的数字放在数组的右边。

```
int Partition(int data[], int length, int start, int end)
{
    if(data == NULL || length <= 0 || start < 0 || end >= length)
        throw new std::exception("Invalid Parameters");
    srand((unsigned)time(NULL));
    int index = start + rand() % length;
    Swap(&data[index], &data[end]);

    int small = start - 1;              //保存一个指针，该指针前面的值数字都比选中的数字小。
    for(int i = start; i < end; i++)
    {
        if(data[i] < data[end])
        {
            small++;
            if(small != i)
                swap(&data[i], &data[small]);
        }
    }

    small++;
    swap(&data[small], &data[end]);

    return small;
}
```

**这个函数贼鸡儿好使，Markdown**

>然后就可以用递归的思路分别对左右两边排序。

```
void QuickSort(int data[], int length, int start, int end)
{
    if(start == end)
        return ;
    int index = Partition(data, length, start, end);
    if(index > start)
        QuickSort(data, length, start, index -1);
    if(index < end)
        QuickSort(data, length, start + 1, end);
}
```

## 面试题8:旋转数组的最小数字

**把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3, 4, 5, 1, 2}为{1, 2, 3, 4, 5}的一个旋转，该数组的最小值为1**

>旋转之后的数组实际上可以分为两个排序的数组，而且前面的子数组的元素都大于或者等于后面子数组的元素。  
>我们可以采用**二分查找法**，找到数组中间的元素，如果该中间元素位于前面的递增数组，它应该大于或者等于第一个指针指向的元素。此时数组中最小的元素应该位于中间元素的后面。  
>反之，如果该中间元素位于后面的递增数组，它应该小于等于第二个指针指向的元素。此时数组中最小的元素应该位于中间元素前面。  
>而当数组的第一个元素小于最后一个元素，说明数组已排序，可以直接返回第一个数字了。  
>特例：如果当第一个元素，中间元素，最后一个元素都相等时，我们无法判断中间数字位于前面还是后面，此时需要顺序查找该段。

## 面试题9:斐波那契数列

**写一个函数，输入n，求斐波那契数列的第n项。**  
**f(0) = 0**  
**f(1) = 0**  
**f(n) = f(n-1) + f(n-2)**

>一步步迭代即可，复杂度为O(n)

#### 面试题9.2:青蛙跳台阶问题

**一只青蛙一次可以跳上1个台阶，也可以跳上2个台阶，求该青蛙跳上一个n级的台阶一共有多少种跳法。**

## 面试题10:二进制中1的个数

**请实现一个函数，输入一个整数，输出该数二进制表示中1的个数。例如把0表示成1001，有2个1.因此如果输入9，则输出2.**

>常规思路：一步步判断每一位是否是1.可以用1<<i然后和该数做与运算，如果结果为1，说明第i位是1.

>惊喜思路：把一个整数减1，再和原整数做与运算，会把该整数最右边的一个1变成0.

```
int NumberOf1(int n)
{
    int count = 0;
    while(n)
    {
        count++;
        n = (n - 1) & n;
    }
    return count;
}
```

## 面试题11：数值的整数次方

