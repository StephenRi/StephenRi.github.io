---
layout:     post
title:      "[Learning]剑指Offer"
subtitle:   "剑指Offer刷题记录"
date:       2018-03-02 12:00:00
author:     "Stephen.Ri"
header-img: "img/read-bg.jpg"
catalog: true
tags:
    - Learning
---

## 面试题1:赋值运算符函数

**类型CMyString，请为该类型添加赋值运算符函数。**

```
CMyString & CMyString::operator = (const CMyString & str)
{
    if(this == &str)
        return *this;
    delete [] m_pData;
    m_pDate = NULL;
    m_pData = new char[strlen(str.m_pData) + 1];
    strcpy(m_pdata, str.m_pData);
    return *this;
}
```

1. 只有返回一个引用（\*this），才可以被连续赋值。

2. 参数设置为引用，防止从形参到实参调用复制构造函数。

3. 释放自己本身的内存，防止程序发生内存泄漏。

4. 要判断传入参数和\*this是否是同一个实例。


## 面试题3:二维数组中的查找

**在一个二维数组中，每一行都按照从左到右递增的顺序排列，每一列都按照从上倒下递增的顺序排列。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否包含该整数。**

>首先选取数组中右上角的数字。如果该数字等于要查找的数字，查找结束；  
>如果该数字大于要查找的数字，剔除这个数字所在的列；  
>输入该数字小于要查找的数字，剔除这个数字所在的行。

1. STL中的vector每次扩充容量时，新的容量都是前一次的两倍。

## 面试题4:替换空格

**请实现一个函数，把字符串中的每个空格替换成“%20”。例如输入“We are happy.”，则输出“We%20are%20happy”**

>假设我们要在原来的字符串上做替换，并且输入的字符串后面有足够多的空余内存。

>首先遍历一次字符串，统计处字符串中空格的总数，计算出替换后字符串的总长度。  
>从字符串的后面开始复制和替换。准备两个指针p1和p2，分别指向原字符串的末尾和替换后字符串的末尾。  
>一步步向前移动p1，逐个把它指向的字符复制到p2未知。如果p1指向的是空格，就变成“%20”。

1. 合并两个数组时，如果从前往后复制每个数字需要重复移动数字多次，那么我们可以考虑**从后往前**复制，这样能减少移动的次数，提高效率。

## 面试题5:从尾到头打印链表

**输入一个链表的头节点，从尾到头反过来打印出每个节点的值。**

>链表遍历的顺序是从头到尾的顺序，输出的顺序却是从尾到头，这就是典型的**后进先出**，我们可以用**栈**来实现这种顺序。

`stack<ListNode *> nodes`

## 面试题6:重建二叉树

**输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1, 2, 4, 7, 3, 5, 6, 8}和中序遍历序列{4, 7, 2, 1, 5, 3, 8, 6}，重建二叉树并输出头节点。**

>前序遍历的第一个数字是根节点的值，扫描中序遍历，就能确定根节点的值的位置。  
>根据中序遍历的特点，根节点的值前面的就是左子树的值，根节点的值后面的就是右子树的值。  
>可以用**递归**实现。

## 面试题7:用两个栈实现队列

**用两个栈实现一个队列。队列的声明如下，请实现它的两个函数appendTail和deleteHead，分别完成在队列尾部插入节点和在队列头部删除节点的功能。**

>我们有两个栈stack1和stack2。  
>插入的时候都是直接用stack1.push(element)。  
>删除的时候：当stack2中不为空时，stack2中栈顶的元素就是最先进入队列的元素，可以弹出。如果stack2为空，我们就把stack1中的元素逐个弹出并压入stack2，因为先进入stack1的元素在栈底，经过弹出并压入之后处于stack2的栈顶，可以直接弹出。

## 番外题：快速排序

>实现快拍的关键在于现在数组中选择一个数字，接下来把数组中的数字分为两部分，比选择的数字小的数字放在数组的左边，比选择的数字大的数字放在数组的右边。

```
int Partition(int data[], int length, int start, int end)
{
    if(data == NULL || length <= 0 || start < 0 || end >= length)
        throw new std::exception("Invalid Parameters");
    srand((unsigned)time(NULL));
    int index = start + rand() % length;
    Swap(&data[index], &data[end]);

    int small = start - 1;              //保存一个指针，该指针前面的值数字都比选中的数字小。
    for(int i = start; i < end; i++)
    {
        if(data[i] < data[end])
        {
            small++;
            if(small != i)
                swap(&data[i], &data[small]);
        }
    }

    small++;
    swap(&data[small], &data[end]);

    return small;
}
```

**这个函数贼鸡儿好使，Markdown**

>然后就可以用递归的思路分别对左右两边排序。

```
void QuickSort(int data[], int length, int start, int end)
{
    if(start == end)
        return ;
    int index = Partition(data, length, start, end);
    if(index > start)
        QuickSort(data, length, start, index -1);
    if(index < end)
        QuickSort(data, length, start + 1, end);
}
```

## 面试题8:旋转数组的最小数字

**把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3, 4, 5, 1, 2}为{1, 2, 3, 4, 5}的一个旋转，该数组的最小值为1**

>旋转之后的数组实际上可以分为两个排序的数组，而且前面的子数组的元素都大于或者等于后面子数组的元素。  
>我们可以采用**二分查找法**，找到数组中间的元素，如果该中间元素位于前面的递增数组，它应该大于或者等于第一个指针指向的元素。此时数组中最小的元素应该位于中间元素的后面。  
>反之，如果该中间元素位于后面的递增数组，它应该小于等于第二个指针指向的元素。此时数组中最小的元素应该位于中间元素前面。  
>而当数组的第一个元素小于最后一个元素，说明数组已排序，可以直接返回第一个数字了。  
>特例：如果当第一个元素，中间元素，最后一个元素都相等时，我们无法判断中间数字位于前面还是后面，此时需要顺序查找该段。

## 面试题9:斐波那契数列

**写一个函数，输入n，求斐波那契数列的第n项。**  
**f(0) = 0**  
**f(1) = 0**  
**f(n) = f(n-1) + f(n-2)**

>一步步迭代即可，复杂度为O(n)

#### 面试题9.2:青蛙跳台阶问题

**一只青蛙一次可以跳上1个台阶，也可以跳上2个台阶，求该青蛙跳上一个n级的台阶一共有多少种跳法。**

## 面试题10:二进制中1的个数

**请实现一个函数，输入一个整数，输出该数二进制表示中1的个数。例如把0表示成1001，有2个1.因此如果输入9，则输出2.**

>常规思路：一步步判断每一位是否是1.可以用1<<i然后和该数做与运算，如果结果为1，说明第i位是1.

>惊喜思路：把一个整数减1，再和原整数做与运算，会把该整数最右边的一个1变成0.

```
int NumberOf1(int n)
{
    int count = 0;
    while(n)
    {
        count++;
        n = (n - 1) & n;
    }
    return count;
}
```

## 面试题11：数值的整数次方

**实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。**

1. 考虑底数为0的情况。

2. 考虑指数为负数的情况。

>惊喜思路：  
>当n为偶数：pow(a, n) = pow(a, n/2) * pow(a, n/2)  
>当n为奇数：pow(a, n) = pow(a, (n-1)/2) * pow(a, (n-1)/2)

## 面试题12:打印1到最大的n位数

**输入数字n，按顺序打印出从1到最大的n位十进制数。比如输入3，打印出1，2，3一直到最大的3位数999.**

>全排列问题，用递归实现

```
void PrintRecursively(char * number, int length, int index)
{
    if(index == length - 1)
    {
        PrintNumber(number);
        return ;
    }
    for(int i = 0; i < 10; i++)
    {
        number[index + 1] = '0' + i;
        PrintRecursively(number, length, index + 1);
    }
}
```

## 面试题13:在O(1)的时间内删除链表节点

**给定单向链表的头指针和一个节点指针，定义一个函数在O(1)的时间删除该节点。**

>要删除一个节点i，我们需要把i前面节点的next指针指向i后面的节点j。

>我们可以将j的内容复制到i，然后让i的next指针指向j后面的节点。效果就是把i节点给删除了。

## 面试题14:调整数组顺序使奇数位于偶数前面

**输入一个整数数组，实现一个函数来调整数组中的数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。**

>快速排序中Partition的应用。

## 面试题15:链表中倒数第k个节点

**输入一个链表，输出该链表中倒数第k个节点。**

>为了实现遍历链表一次就可以找到倒数第k个节点，我们定义两个指针p1和p2。  
>p1先从链表的头指针向前走k-1步，p2不动。  
>然后从第k步开始，两个指针一起向前移动。当p1走到链表的尾节点时，p2刚好在倒数第k个节点。

## 面试题16:反转链表

**定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。**

>h --> i --> j  假设当前遍历到节点i，h之前的链表已经反转完成。
>h <-- i     j  我们需要将i的next指针指向h，而在此之前我们需要一个指针指向j，防止节点i处断开。

```
ListNode * ReverseList(ListNode * pHead)
{
    ListNode * pReversedHead = NULL;
    ListNode * pNode = pHead;           //i
    ListNode * pPrev = NULL;            //h
    ListNode * pNext = NULL;            //j
    while(pNode != NULL)
    {
        pNext = pNode->m_pNext;
        if(pNext == NULL)
            pReversedHead = pNode;
        pNode->next = pPrev;
        pPrev = pNode;
        pNode = pNext;
    }
    return pReversedHead;
}
```

## 面试题17:合并两个排序的链表

**输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是按照递增排序的。**

>合并排序问题。  
>每次比较两个链表的头节点，值较小的头节点作为新链表的下一个节点。

## 面试题18:树的字结构

**输入两颗二叉树A和B，判断B是不是A的字结构。**

>1. 第一步在树A中查找与B根节点的值一样的节点，这实际是树的遍历。递归。  
>2. 第二步判断树A中以R为根节点的子树是不是和树B有相同的结构。递归。

## 面试题19:二叉树的镜像

**请完成一个函数，输入一个二叉树，该函数输出它的镜像**

>我们先前序遍历这棵树的每个节点，如果遍历到的节点有子节点，就交换它的两个子节点。当交换完所有非叶节点的左右孩子之后，就得到了树的镜像。

## 面试题20:顺时针打印矩阵

**输入一个矩阵，按照从外到里以顺时针的顺序依次打印出每一个数字。**

>由于是从外圈到内圈依次打印，我们可以把矩阵想象成若干个圈。  
>每个圈的起点，即左上角的点的行标startX和列标startY总是相同的。循环继续的条件是`startX * 2 < row && startY * 2 < col`。  

>打印每一圈需要横竖弯勾四步，条件如下：  
>1. 第一步必须。  
>2. 第二步需要终止行号endX大于起始行号startX。（至少两行）  
>3. 第三步需要终止列号endY大于起始列号startY。（至少两行两列）  
>4. 第四步需要终止行号endX比起始行号startX大2。（至少三行两列）  

## 面试题21:包含min函数的栈

**定义栈数据结构，请在该类型中实现一个能够得到栈的最小元素的min函数。在该栈中，调用min，push和pop的时间复杂度都是O(1)**

>除了**数据栈**之外，我们每次把最小元素都保存起来放到另外一个**辅助栈**中。  

>如果每次把最小元素压入辅助栈，那么就能保证辅助栈的栈顶一直都是最小元素。当最小元素从数据栈内被弹出之后，同时弹出辅助栈的栈顶元素，此时辅助栈的新栈顶元素就是下一个最小值。  

## 面试题22:栈的压入、弹出序列

**输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出序列。假设压入栈的所有数字都不相等。**

>维护一个栈。  

>如果下一个弹出的数字刚好是栈顶元素，那么就直接弹出。如果下一个弹出的数字不在栈顶，我们把压栈序列中还没有入栈的数字压入辅助栈，直到把下一个需要弹出的数字压入栈顶位置。

## 面试题23:从上往下打印二叉树

**从上往下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。**

>先进先出，使用**队列**来遍历

## 面试题24:二叉搜索树的后序遍历序列

**输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是返回true，否则返回false。假设输入的数组的任意两个数字都不相同。**

>在后序遍历得到的序列中，最后一个数字是树的根节点的值。  

>数组中前面的数字可以分为两部分：第一部分是左子树的节点，都比根节点的值小；第二部分是右子树的节点的值，都比根节点的值大。 

## 面试题25:二叉树中和为某一值的路径

**输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。**

>前序遍历的方式访问二叉树。用一个栈来记录路径  

>开始时把该节点压到栈中，并累加该节点的值。符合要求就打印出路径。如果当前节点不是叶节点，继续访问其子节点。最后记得返回父节点之前把该节点弹出栈。  

## 面试题26:复杂链表的复制

**请实现函数ComplexListNode * Clone(ComplexListNode * pHead)，复制一个复杂链表。在复杂链表中，每个节点除了有一个m_pNext指针指向下一个节点外，还有一个m_pSibling指向链表中的任意节点或者NULL。**

>常规思路：  
>第一步复制原始链表上的每一个节点，并用m_pNext链接起来；第二步是设置每个节点的m_pSibling指针。

>优化思路：  
>1. 复制链表的每个节点N，得到N'，但是把N'放在N的后面。  
>2. 假设N的m_pSibling指向S，那么其对应复制出来的N'是N的m_pNext指向的节点，同样S'是S的m_pNext指向的节点。  
>3. 把新链表拆分成两个链表：把奇数位置的节点链接起来就是原始链表；把偶数位置的节点链接起来就是复制链表。

## 面试题27:二叉搜索树与双向链表

**输入一颗二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。**

>在二叉搜索树中，左子节点的值总是小于父节点的值；右子节点的值总是大于父节点的值。

>**中序遍历**的结果就是从小到大的顺序排列。因此可以在中序遍历的过程中建立双向链表。

```
/**
 * pNode                当前节点
 * pLastNodeInList      记录已拍好序的最后一个节点，起始就是中序遍历中的上一个遍历到的节点
 */
void ConvertNode(BinaryTreeNode * pNode, BinaryTreeNode ** pLastNodeInList)
{
    if(pNode == NULL)
        return ;
    BinaryTreeNode * pCurrent = pNode;
    
    if(pCurrent->m_pLeft != NULL)
        ConvertNode(pCurrent->m_pLeft, pLastNodeInList);

    pCurrent->m_pLeft = *pLastNodeInList;
    if(*pLastNodeInList != NULL)
        (*pLastNodeInList)->m_pNext = pCurrent;
    *pLastNodeInList = pCurrent;

    if(pCurrent->m_pRight != NULL)
        ConvertNode(pCurrent->m_pRight, pLastNodeInList);
}
```

## 面试题28:字符串的排列

**输入一个字符串，打印出该字符串中字符的所有排列。例如输入字符串abc，则打印出字符a, b, c所能排列出的所有字符串abc,acb,bac,bca,cab,cba。**

>常规思路：  
>典型的dfs遍历，带上剪枝。
>然而，如果采用这种方法，剪枝也是消耗时间的。
>如果每次把剩余的字符作为一个参数传给递归函数，可以省去剪枝的时间开销，那么空间又会有很大开销。

>优化思路：  
>还是按照dfs的路子走，但是采用`Permutation(char * pStr, char* pBegin)`来进行递归，pBegin是dfs层数。每次拿第pBegin个字符和后面的字符依次交换位置来划分下一层。  
>这种方法既不需要额外的剪枝时间，又不需要额外的空间开销。机智如你，双击666.

##
