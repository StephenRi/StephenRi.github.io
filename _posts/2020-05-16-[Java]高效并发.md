---
layout:     post
title:      "[Java]高效并发"
subtitle:   "深入理解Java虚拟机-线程安全与锁优化"
date:       2020-05-16 12:00:00
author:     "Stephen.Ri"
header-img: "img/apple2.jpg"
catalog: true
tags:
    - Java
--- 

## Java内存模型与线程

### 一致性

在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存（Main Memory）。

![处理器、高速缓存、主内存之间的交互关系]({{site.baseurl}}/img/imgInBlog/thread1.jpg)

为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有MSI、MESI（Illinois Protocol）、MOSI、Synapse、Firefly及Dragon Protocol等。

### Java内存模型

作用是屏蔽各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。

线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。

![线程、主内存、工作内存关系]({{site.baseurl}}/img/imgInBlog/thread2.jpg)

| 内存 | 存储内容 | 对应内容 | 物理硬件 |
| :---: | :---: | :---: | :---: |
| 主内存 | 所有的变量（包括实例字段，静态字段和构成数组对象的元素） | Java堆中的对象实例数据 | 物理内存 |
| 工作内存 | 该线程使用到的变量的主内存副本拷贝 | 虚拟机栈中的部分区域 | 优先存储于寄存器和高速缓存中 |

#### 内存间交互

Java内存模型定义了8种原子操作：

| 内存 | 发生位置 | 作用 |
| :---: | :---: | :---: |
| lock | 主内存 | 把一个变量标识为一条线程独占
| unlock | 主内存 | 释放锁定的变量
| read | 主内存 | 把一个变量的值从主内存传输到线程的工作内存
| load | 工作内存 | 把read操作从主内存中得到的变量值放入工作内存的变量副本
| use | 工作内存 | 把工作内存中一个变量的值传递给执行引擎
| assign | 工作内存 | 把一个从执行引擎接收到的值赋给工作内存的变量
| store | 工作内存 | 把工作内存中一个变量的值传送到主内存中
| write | 主内存 | 把store操作从工作内存中得到的变量的值放入主内存的变量

#### volatile特殊规则

volatile是Java虚拟机提供的最轻量级的同步机制

1. **保证变量对所有线程的可见性**：当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。但是Java里面的运算并非原子操作，导致volatile变量的运算在并发下一样是不安全的。

2. **禁止指令重排序优化**

#### 先行发生原则

先行发生是Java内存模型中定义的两项操作之间的偏序关系，如果说操作A先行发生于操作B，其实就是说在发生操作B之前，操作A产生的影响能被操作B观察到。

Java内存模型中天然的先行发生原则：

1. 程序次序规则（Program Order Rule）：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作
2. 管程锁定规则（Monitor Lock Rule）：一个unlock操作先行发生于后面对同一个锁的lock操作
3. volatile变量规则（Volatile Variable Rule）：对一个volatile变量的写操作先行发生于后面对这个变量的读操作
4. 线程启动规则（Thread Start Rule）：Thread对象的start()方法先行发生于此线程的每一个动作
5. 线程终止规则（Thread Termination Rule）：线程中的所有操作都先行发生于对此线程的终止检测
6. 线程中断规则（Thread Interruption Rule）：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生
7. 对象终结规则（Finalizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始
8. 传递性（Transitivity）：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论

### 线程

#### 线程的实现

线程是比进程更轻量级的调度执行单位，线程的引入，可以把一个进程的资源分配和执行调度分开，各个线程既可以共享进程资源（内存地址、文件I/O等），又可以独立调度（线程是CPU调度的基本单位）。

| 线程 | 定义 | 模型 | 优点 |
| :---: | :---: | :---: | :---: |
| 内核线程 | 直接由操作系统内核支持的线程，由内核完成线程切换，线程调度，将线程任务映射到各处理器 | 一对一线程模型 | 程序可以使用高级接口——轻量级线程。实现简单
| 用户线程 | 完全建立在用户空间的线程库上，系统内核不能感知线程存在的实现 | 一对多线程模型 | 不需要切换到内核态，因此操作快速且低消耗，也可以支持规模更大的线程数量
| 混合实现 | 多对多线程模型 | 轻量级进程则作为用户线程和内核线程之间的桥梁

> 对于Sun JDK来说，它的Windows版与Linux版都是使用一对一的线程模型实现的

#### 线程调度

| 线程调度 | 定义 | 优点 | Java |
| :---: | :---: | :---: | :---: |
| 协同式调度 | 线程的执行时间由线程本身来控制，线程执行完后，要主动通知系统切换到另外一个线程上 | 实现简单，切换线程操作对自己可知 | 不使用
| 抢占式调度 | 每个线程将由系统来分配执行时间 | 线程的执行时间系统可控，不会有一个线程导致进程阻塞 | 使用

#### 线程状态转换

![线程状态转换关系]({{site.baseurl}}/img/imgInBlog/thread3.jpg)

| 状态 | 定义 | 触发 |
| :---: | :---: | :---: |
| 新建 | 创建后尚未启动 |
| 运行 | 包括操作系统中的Running和Ready
| 无限期等待 | 等待被其他线程显式唤醒，不会被分配CPU执行时间 | Object.wait()，Thread.join()，LockSupport.park()
| 限期等待 | 一定时间后，系统自动唤醒 | Thread.sleep()，Object.wait(timeout)，Thread.join(timeout)，LockSupport.parkNanos(),LockSupport.parkUntil()
| 阻塞 | 等待着获取到一个排他锁
| 结束 | 线程结束执行
