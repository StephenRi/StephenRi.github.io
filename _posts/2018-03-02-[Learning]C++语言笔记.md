---
layout:     post
title:      "[Learning]C++语言笔记"
subtitle:   "程序员面试宝典中C++语言部分的笔记"
date:       2018-03-02 12:00:00
author:     "Stephen.Ri"
header-img: "img/read-bg.jpg"
catalog: true
tags:
    - Learning
---

## 基本语法

#### printf从右到左压栈

printf计算参数时是**从右到左压栈**的。例如

`printf("%d, %d\n", *ptr, *(++ptr))`

这句话是先算后面的参数，++后再算前面的，因此两个值是一样的。

#### (int &)a输出内存值

该类型转换的意思是把这个内存地址里的值当成整数输出。

`if float a = 1.0f; (int)a == (int &)a`为false，

`if float a = 0.0f; (int)a == (int &)a`为true。

因为内存里float型和int型的1不同，0相同。

#### 小端存储

在X86系列的机器中，数据的存储是“小端存储”，即对于一个跨多个字节的数据，其低位存放在低地址单元，高位存放在高地址单元。比如一个int型的`0x12345678`要存放在0x00000000～0x00000003四个内存单元中，那么0x00000000中存放的是低位的0x78.

## 预处理，const和sizeof

#### 预处理器

C/C++编译系统编译程序的过程为预处理、编译、链接。

预处理器主要处理一下内容：

1. 文件包含：`#include<iostream>`

2. 宏替换：`#define SECONDS_PER_YEAR (60 * 60 * 24 * 365)UL`，`#define MIN(A,B) (((A)<=(B)?A:B)`

3. 条件编译指令：`#ifndef`

4. 其他：`#line`, `#error`, `pragma`等。

#### const

**const常量赋值时必须同时初始化**

###### const修饰指针

1. const位于\*左边：例如`const int * a = &b`，const修饰指针所指向的变量a。

2. const位于\*右边：例如`int * const a = &b`，const修饰指针本身。

###### const修饰成员函数

`int Point::GetY() const {return YVal;}`

被定义成const的成员函数，如果企图修改数据成员的值，编译器就会报错。说明这个函数是**“只读”**函数。

但是如果数据成员被mutable修饰，就又可以修改了了。

###### const与#define

const有数据类型，可以进行类型安全检查。

#### sizeof

**sizeof**是计算栈中分配的大小。

1. `char * ss1 = "0123456789"`，是一个字符指针，sizeof(ss1)=4。

2. `char ss2[] = "0123456789"`，是一个字符数组，加上隐含的“\0”，sizeof(ss2)=11。

3. `char ss3[100] = "0123456789"`，是一个字符数组，sizeof(ss3)=100。

4. sizeof结构体，当结构体内的元素的长度都小于处理器的位数时，以结构体内最长的数据元素为对齐单位。否则以处理器的位数为对齐单位。

###### sizeof和strlen的区别

1. **strlen**的内部实现是用一个循环计算字符串的长度，直到“\0”为止。

2. sizeof可以用类型（包括结构和类）做参数，strlen只能用char\*。

3. sizeof是操作符，strlen是函数。

#### 内联函数与宏定义

内联函数与普通函数相比可以**加快程序运行的速度**，因为不需要中断调用，在编译时内联函数可以直接被镶嵌到目标代码中。而宏只是一个简单的替换。

内联函数要做类型检查，比宏更**安全**。

## 指针与引用

#### 指针和引用的差别

1. 引用必须指向某些对象，不能为空。声明引用时，必须同时初始化。

2. 使用指针之前，应该测试合法性，防止其为空。

3. 指针可以被从新赋值以指向另一个不同的对象。

#### 函数参数传递

1. 值传递

2. 指针传递（地址传递）

3. 引用传递

```
char *strA(){
    char * str = "Hello World";
    return str;
}
```

`char c[] = "hello"`是分配一个局部数组。局部数组是局部变量，对应内存中的栈。

`char *c = "hello`是分配一个指针变量。字符串常量保存在只读的数据段。这里的指针也是局部变量，所以需要return一个地址。

程序内存空间如下图所示：

 ![程序内存空间]({{site.baseurl}}/img/imgInBlog/cpp1.jpg)

 ![程序内存空间]({{site.baseurl}}/img/imgInBlog/cpp2.jpg)

注意**堆**里存放程序员动态分配的内存空间，包括malloc和new的内存。

#### 函数指针

`Long (* fun)(int)`

上面是一个**函数指针**，这个指针的返回值是long，参数是int。

`Long * fun(int)`

去掉（）后，它就是一个**指针函数**，返回一个long型指针的函数。

#### 指针数组 vs. 数组指针

`int *ptr[]`

指针数组

`int (*ptr)[]`

数组指针

#### 迷途指针 vs. 空指针

1. `delete pInt`当delete一个指针的时候，实际上是编译器释放内存，但是指针本身仍然存在，这时是一个迷途指针。

2. `pInt = null`使用该语句将指针置为空。

#### malloc/free vs. new/delete

都是用来申请动态内存和释放内存。

1. malloc/free是C/C++语言的标准库函数。

2. new/delete是C++的操作符。对于**非内部数据类型的对象**而言，只用malloc无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。因此，C++需要一个能完成动态内存分配和初始化工作的运算符new。

#### this指针

1. this指针本质上是一个函数参数，只是编译器隐藏起形式的，语法层面上的参数。this只能在成员函数中使用，全局函数，静态函数无法使用。

2. this在成员函数的开始前构造，在成员的结束后清楚，这个生命周期同任何一个函数的参数是一样的。

3. this指针并不占用对象的空间。所有成员函数的参数，不管是不是隐含的，都不会占用对象的空间，只会占用参数传递时的栈空间，或者直接占用一个寄存器。

4. this指针会因编译器的不同而有不同的放置位置。可能是堆，栈，也可能是寄存器。

5. this是个指向对象的“常指针”，无法改变。

## STL模版和容器

#### 泛型函数

`template<typename T> T fun(T x, T y){}`

#### 容器

| 数据结构 | 描述 | 头文件 |
| --- | --- | ---|
| 向量（vector） | 连续存储的元素 | vector |
| 列表（list） | 由节点组成的双向链表 | list |
| 集合（set） | 红黑树，默认按升序 | set |
| 映射（map） | 红黑树，{key, value} | map |
| Hash映射（unordered_map） | Hash | unordered_map |
| 队列（queue） | 先进先出 | queue |
| 双队列（deque） | 连续存储的指向不同元素的指针所组成的数组 | deque |
| 优先队列（priority_queue） | 排序队列，默认top()最大 | queue |
| 栈（stack） | 后进先出 | stack |


